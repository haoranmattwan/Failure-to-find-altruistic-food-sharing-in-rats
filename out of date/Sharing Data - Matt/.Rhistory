mean_rel_soc_c1 <- mean(Raw_data$`Rel. Soc`[ind_Cond1])
mean_rel_soc_c2 <- mean(Raw_data$`Rel. Soc`[ind_Cond2])
mean_rel_soc_c3 <- mean(Raw_data$`Rel. Soc`[ind_Cond3])
mean_rel_soc_c4 <- mean(Raw_data$`Rel. Soc`[ind_Cond4])
mean_rel_soc_c5 <- mean(Raw_data$`Rel. Soc`[ind_Cond5])
mean_rel_soc_c6 <- mean(Raw_data$`Rel. Soc`[ind_Cond6])
mean_rel_soc_c7 <- mean(Raw_data$`Rel. Soc`[ind_Cond7])
# Relative food response
mean_rel_food_c1 <- mean(Raw_data$`Rel. Food`[ind_Cond1])
mean_rel_food_c2 <- mean(Raw_data$`Rel. Food`[ind_Cond2])
mean_rel_food_c3 <- mean(Raw_data$`Rel. Food`[ind_Cond3])
mean_rel_food_c4 <- mean(Raw_data$`Rel. Food`[ind_Cond4])
mean_rel_food_c5 <- mean(Raw_data$`Rel. Food`[ind_Cond5])
mean_rel_food_c6 <- mean(Raw_data$`Rel. Food`[ind_Cond6])
mean_rel_food_c7 <- mean(Raw_data$`Rel. Food`[ind_Cond7])
mean_rel_food_c1    # The mean of food preference in the first condition
mean_rel_food_c3    # The mean of food preference in the Third condition
t_test_food_pref_13 <- t.test(rel_food_c1,rel_food_c3)
mean_rel_food_c1    # The mean of food preference in the first condition
mean_rel_food_c3    # The mean of food preference in the Third condition
rel_food_c1 <- Raw_data$`Rel. Food`[ind_Cond1]
rel_food_c3 <- Raw_data$`Rel. Food`[ind_Cond3]
t_test_food_pref_13 <- t.test(rel_food_c1,rel_food_c3)
t_test_food_pref_13
range(Raw_data$`Rel. Soc`[ind_Cond1 | ind_Cond2, ind_Cond3])
range(Raw_data$`Rel. Soc`[ind_Cond1 & ind_Cond2 & ind_Cond3])
range(Raw_data$`Rel. Soc`[ind_Cond1 | ind_Cond2 | ind_Cond3])
range(Raw_data$`Rel. Soc`[ind_Cond1 | ind_Cond2 | ind_Cond3])
# 0.0000 0.6875
# Should we use the mean instead?
# Mean of social response in cond. 1, 2, and 3
mean_rel_soc_c1
mean_rel_soc_c2
mean_rel_soc_c3
range(Raw_data$`Rel. Soc`[ind_Cond1 | ind_Cond2 | ind_Cond3])
# 0.0000 0.6875
# Should we use the mean instead?
# Mean of social response in cond. 1, 2, and 3
mean_soc_c1 <- mean(Raw_data$`Social ` [ind_Cond1])
mean_soc_c2 <- mean(Raw_data$`Social `[ind_Cond2])
mean_soc_c3 <- mean(Raw_data$`Social `[ind_Cond3])
mean_soc_c1
# 10.25926
mean_soc_c2 <- mean(Raw_data$`Social `[ind_Cond2])
mean_soc_c2
# 13.31818
mean_soc_c3 <- mean(Raw_data$`Social `[ind_Cond3])
mean_soc_c3
rel_food_c3 <- Raw_data$`Rel. Food`[ind_Cond3]
rel_food_c4 <- Raw_data$`Rel. Food`[ind_Cond4]
t_test <- t.test(rel_food_c3,rel_food_c4)
t_test
rel_food_c3 <- Raw_data$`Rel. Food`[ind_Cond3]
rel_food_c4 <- Raw_data$`Rel. Food`[ind_Cond4]
t_test <- t.test(rel_food_c3,rel_food_c4)
t_test
rel_soc_c4 <- Raw_data$`Rel. Soc`[ind_Cond4]
rel_soc_c7 <- Raw_data$`Rel. Soc`[ind_Cond7]
t_test_soc_47 <- t.test(rel_soc_c4,rel_soc_c7)
t_test
rel_food_c4 <- Raw_data$`Rel. Food`[ind_Cond4]
rel_food_c7 <- Raw_data$`Rel. Food`[ind_Cond7]
t_test_food_47 <- t.test(rel_food_c4,rel_food_c7)
t_test_food_47
Tot_Pllt_3 <- Raw_data$`Total pellets`[ind_Cond3]
Tot_Pllt_4 <- Raw_data$`Total pellets`[ind_Cond4]
t_test_pellet_34 <- t.test(Tot_Pllt_3,Tot_Pllt_4)
t_test_pellet_34
Raw_data_sharing <- subset(Raw_data, `Sharing` !=-1)
Raw_data_sharing
View((Raw_data_sharing))
mean_sharing <- mean(Raw_data_sharing$Sharing)
mean_sharing
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
pkgbuild::has_build_tools(debug = TRUE)
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, ifelse(.Platform$OS.type == "windows", "Makevars.win", "Makevars"))
if (!file.exists(M)) file.create(M)
cat("\nCXX14FLAGS=-O3 -march=native -mtune=native",
if( grepl("^darwin", R.version$os)) "CXX14FLAGS += -arch x86_64 -ftemplate-depth-256" else
if (.Platform$OS.type == "windows") "CXX11FLAGS=-O3 -march=corei7 -mtune=corei7" else
"CXX14FLAGS += -fPIC",
file = M, sep = "\n", append = TRUE)
M <- file.path(Sys.getenv("HOME"), ".R", ifelse(.Platform$OS.type == "windows", "Makevars.win", "Makevars"))
file.edit(M)
pair_machine_p <- stan_model(file="pair_model.stan")
pair_machine_p <- stan_model(file="pair_model.stan")
library(rethinking)
library(readr)
library(ggplot2)
setwd("~/Documents/Google Drive/Reed/Learning & Adaptive Behavior Laboratory/Sharing Data - Greg")
Behav <- read_csv("Raw_data.csv")
Behav$Subject <- coerce_index(Behav$Rat)
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
pair_machine_p <- stan_model(file="pair_model.stan")
library("rstan") # observe startup messages
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7')
pair_machine_p <- stan_model(file="pair_model.stan")
pair_machine_p <- stan_model(file="pair_model.stan")
library(rethinking)
library(readr)
library(ggplot2)
setwd("~/Documents/Google Drive/Reed/Learning & Adaptive Behavior Laboratory/Sharing Data - Greg")
Behav <- read_csv("Raw_data.csv")
Behav$Subject <- coerce_index(Behav$Rat)
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
pair_machine_p <- stan_model(file="pair_model.stan")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
pkgbuild::has_build_tools(debug = TRUE)
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, ifelse(.Platform$OS.type == "windows", "Makevars.win", "Makevars"))
if (!file.exists(M)) file.create(M)
cat("\nCXX14FLAGS=-O3 -march=native -mtune=native",
if( grepl("^darwin", R.version$os)) "CXX14FLAGS += -arch x86_64 -ftemplate-depth-256" else
if (.Platform$OS.type == "windows") "CXX11FLAGS=-O3 -march=corei7 -mtune=corei7" else
"CXX14FLAGS += -fPIC",
file = M, sep = "\n", append = TRUE)
M <- file.path(Sys.getenv("HOME"), ".R", ifelse(.Platform$OS.type == "windows", "Makevars.win", "Makevars"))
file.edit(M)
library("rstan") # observe startup messages
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7')
pair_machine_p <- stan_model(file="pair_model.stan")
pair_machine_p <- stan_model(file="pair_model.stan")
pair_machine_p <- stan_model(file="pair_model.stan")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
pair_machine_p <- stan_model(file="pair_model.stan")
library(rethinking)
library(rethinking)
# Run all of the following code, either by selecting all the code and
# pressing the "Run" button (if you are using RStudio) or by copying
# the code and pasting it into the R console and pressing return.
# This bit of code installs the "rstan" package, which is essential to
# the Stan programming language that will do the heavy lifting in the
# background later in the course. Without running this installer first,
# the "rethinking" package won't work properly.
remove.packages("rstan")
install.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
pkgbuild::has_build_tools(debug = TRUE)
# Once "rstan" is installed, we can install the "rethinking" package
# proper, drawn directly from the author's website.
install.packages(c("mvtnorm","loo","coda"), repos="https://cloud.r-project.org/",dependencies=TRUE)
install.packages('rethinking',type='source')
library("rstan")
library("rethinking")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
# If everything has gone according to plan, you should now be able
# to to use the full scope of the tools in the rethinking package.
# If you run into difficulty, let me know ASAP so we can
# troubleshoot the problem.
library(rethinking)
library(readr)
library(ggplot2)
setwd("~/Documents/Google Drive/Reed/Learning & Adaptive Behavior Laboratory/Sharing Data - Greg")
Behav <- read_csv("Raw_data.csv")
Behav$Subject <- coerce_index(Behav$Rat)
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
pair_machine_p <- stan_model(file="pair_model.stan")
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
# Run all of the following code, either by selecting all the code and
# pressing the "Run" button (if you are using RStudio) or by copying
# the code and pasting it into the R console and pressing return.
# This bit of code installs the "rstan" package, which is essential to
# the Stan programming language that will do the heavy lifting in the
# background later in the course. Without running this installer first,
# the "rethinking" package won't work properly.
remove.packages("rstan")
install.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
pkgbuild::has_build_tools(debug = TRUE)
# Once "rstan" is installed, we can install the "rethinking" package
# proper, drawn directly from the author's website.
install.packages(c("mvtnorm","loo","coda"), repos="https://cloud.r-project.org/",dependencies=TRUE)
install.packages('rethinking',type='source')
library("rstan")
library("rethinking")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
# If everything has gone according to plan, you should now be able
# to to use the full scope of the tools in the rethinking package.
# If you run into difficulty, let me know ASAP so we can
# troubleshoot the problem.
library(rethinking)
library(readr)
library(ggplot2)
setwd("~/Documents/Google Drive/Reed/Learning & Adaptive Behavior Laboratory/Sharing Data - Greg")
Behav <- read_csv("Raw_data.csv")
Behav$Subject <- coerce_index(Behav$Rat)
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
pair_machine_p <- stan_model(file="pair_model.stan")
choice_output <- list()
cq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Condition!=5)&(Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),N=Behav$Social[dex]+Behav$Food[dex],condID=Behav$Condition[dex],F=Behav$Food[dex])
dat$condID[dat$condID>5] <- dat$condID[dat$condID>5]-1
choice_output[s] <- list(sampling(pair_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
cq[s] <- list(extract.samples(choice_output[[s]]))
cq[[s]]$prob <- inv_logit(cq[[s]]$intercept)
}
cq[s+1] <- list(extract.samples(choice_output[[s]]))
cq[[s+1]]$intercept <- matrix(0,nrow(cq[[1]]$intercept),ncol(cq[[1]]$intercept))
for (k in 1:s) {
cq[[s+1]]$intercept <- cq[[s+1]]$intercept + cq[[k]]$intercept/s
}
cq[[s+1]]$prob <- inv_logit(cq[[s+1]]$intercept)
plotdata <- data.frame(
name = c( rep("Cond 1",8000), rep("Cond 2",8000), rep("Cond 3",8000), rep("Cond 4",8000), rep("Cond 6",8000), rep("Cond 7",8000) ),
intercept = c( cq[[s+1]]$intercept[,1],cq[[s+1]]$intercept[,2],cq[[s+1]]$intercept[,3],cq[[s+1]]$intercept[,4],cq[[s+1]]$intercept[,5],cq[[s+1]]$intercept[,6] )
)
p <- ggplot(plotdata, aes(x=name, y=intercept, fill=name)) +
geom_violin()
print(p)
plotdata <- data.frame(
name = c( rep("Cond 1",8000), rep("Cond 2",8000), rep("Cond 3",8000), rep("Cond 4",8000), rep("Cond 6",8000), rep("Cond 7",8000) ),
proportion = c( cq[[s+1]]$prob[,1],cq[[s+1]]$prob[,2],cq[[s+1]]$prob[,3],cq[[s+1]]$prob[,4],cq[[s+1]]$prob[,5],cq[[s+1]]$prob[,6] )
)
p <- ggplot(plotdata, aes(x=name, y=proportion, fill=name)) +
geom_violin(scale="width")
print(p)
intake_machine_p <- stan_model(file="intake_model.stan")
intake_machine_p <- stan_model(file="intake_model.stan")
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
intake_machine_p <- stan_model(file="intake_model.stan")
Behav$Subject <- coerce_index(Behav$Rat)
coerce_index(Behav$Rat)
intake_machine_p <- stan_model(file="intake_model.stan")
intake_output <- list()
iq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),condID=Behav$Condition[dex],P=Behav$Food[dex]*Behav$FoodAmmt[dex],Shr=Behav$Sharing[dex],Lft=Behav$PelletsLeft[dex])
dat$Shr[dat$Shr<0] <- 0
dat$Lft[dat$Lft<0] <- 0
dat$NP <- dat$Shr + dat$Lft
intake_output[s] <- list(sampling(intake_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
iq[s] <- list(extract.samples(intake_output[[s]]))
iq[[s]]$is <- iq[[s]]$intercept + iq[[s]]$self
iq[[s]]$pellets_left <- exp(iq[[s]]$intercept)
iq[[s]]$pellets_taken <- exp(iq[[s]]$is)
}
coerce_index(Behav$Rat)
intake_machine_p <- stan_model(file="intake_model.stan")
intake_output <- list()
iq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),condID=Behav$Condition[dex],P=Behav$Food[dex]*Behav$FoodAmmt[dex],Shr=Behav$Sharing[dex],Lft=Behav$PelletsLeft[dex])
dat$Shr[dat$Shr<0] <- 0
dat$Lft[dat$Lft<0] <- 0
dat$NP <- dat$Shr + dat$Lft
intake_output[s] <- list(sampling(intake_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
iq[s] <- list(extract.samples(intake_output[[s]]))
iq[[s]]$is <- iq[[s]]$intercept + iq[[s]]$self
iq[[s]]$pellets_left <- exp(iq[[s]]$intercept)
iq[[s]]$pellets_taken <- exp(iq[[s]]$is)
}
intake_machine_p <- stan_model(file="intake_model.stan")
intake_output <- list()
iq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),condID=Behav$Condition[dex],P=Behav$Food[dex]*Behav$FoodAmmt[dex],Shr=Behav$Sharing[dex],Lft=Behav$PelletsLeft[dex])
dat$Shr[dat$Shr<0] <- 0
dat$Lft[dat$Lft<0] <- 0
dat$NP <- dat$Shr + dat$Lft
intake_output[s] <- list(sampling(intake_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
iq[s] <- list(extract.samples(intake_output[[s]]))
iq[[s]]$is <- iq[[s]]$intercept + iq[[s]]$self
iq[[s]]$pellets_left <- exp(iq[[s]]$intercept)
iq[[s]]$pellets_taken <- exp(iq[[s]]$is)
}
intake_machine_p <- stan_model(file="intake_model.stan")
intake_output <- list()
iq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),condID=Behav$Condition[dex],P=Behav$Food[dex]*Behav$FoodAmmt[dex],Shr=Behav$Sharing[dex],Lft=Behav$PelletsLeft[dex])
dat$Shr[dat$Shr<0] <- 0
dat$Lft[dat$Lft<0] <- 0
dat$NP <- dat$Shr + dat$Lft
intake_output[s] <- list(sampling(intake_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
iq[s] <- list(extract.samples(intake_output[[s]]))
iq[[s]]$is <- iq[[s]]$intercept + iq[[s]]$self
iq[[s]]$pellets_left <- exp(iq[[s]]$intercept)
iq[[s]]$pellets_taken <- exp(iq[[s]]$is)
}
library(rethinking)
library(readr)
library(ggplot2)
setwd("~/Documents/Google Drive/Reed/Learning & Adaptive Behavior Laboratory/Sharing Data - Greg")
Behav <- read_csv("Raw_data.csv")
Behav$Subject <- coerce_index(Behav$Rat)
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
pair_machine_p <- stan_model(file="pair_model.stan")
choice_output <- list()
cq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Condition!=5)&(Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),N=Behav$Social[dex]+Behav$Food[dex],condID=Behav$Condition[dex],F=Behav$Food[dex])
dat$condID[dat$condID>5] <- dat$condID[dat$condID>5]-1
choice_output[s] <- list(sampling(pair_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
cq[s] <- list(extract.samples(choice_output[[s]]))
cq[[s]]$prob <- inv_logit(cq[[s]]$intercept)
}
cq[s+1] <- list(extract.samples(choice_output[[s]]))
cq[[s+1]]$intercept <- matrix(0,nrow(cq[[1]]$intercept),ncol(cq[[1]]$intercept))
for (k in 1:s) {
cq[[s+1]]$intercept <- cq[[s+1]]$intercept + cq[[k]]$intercept/s
}
cq[[s+1]]$prob <- inv_logit(cq[[s+1]]$intercept)
plotdata <- data.frame(
name = c( rep("Cond 1",8000), rep("Cond 2",8000), rep("Cond 3",8000), rep("Cond 4",8000), rep("Cond 6",8000), rep("Cond 7",8000) ),
intercept = c( cq[[s+1]]$intercept[,1],cq[[s+1]]$intercept[,2],cq[[s+1]]$intercept[,3],cq[[s+1]]$intercept[,4],cq[[s+1]]$intercept[,5],cq[[s+1]]$intercept[,6] )
)
p <- ggplot(plotdata, aes(x=name, y=intercept, fill=name)) +
geom_violin()
print(p)
plotdata <- data.frame(
name = c( rep("Cond 1",8000), rep("Cond 2",8000), rep("Cond 3",8000), rep("Cond 4",8000), rep("Cond 6",8000), rep("Cond 7",8000) ),
proportion = c( cq[[s+1]]$prob[,1],cq[[s+1]]$prob[,2],cq[[s+1]]$prob[,3],cq[[s+1]]$prob[,4],cq[[s+1]]$prob[,5],cq[[s+1]]$prob[,6] )
)
p <- ggplot(plotdata, aes(x=name, y=proportion, fill=name)) +
geom_violin(scale="width")
print(p)
intake_machine_p <- stan_model(file="intake_model.stan")
intake_output <- list()
iq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),condID=Behav$Condition[dex],P=Behav$Food[dex]*Behav$FoodAmmt[dex],Shr=Behav$Sharing[dex],Lft=Behav$PelletsLeft[dex])
dat$Shr[dat$Shr<0] <- 0
dat$Lft[dat$Lft<0] <- 0
dat$NP <- dat$Shr + dat$Lft
intake_output[s] <- list(sampling(intake_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
iq[s] <- list(extract.samples(intake_output[[s]]))
iq[[s]]$is <- iq[[s]]$intercept + iq[[s]]$self
iq[[s]]$pellets_left <- exp(iq[[s]]$intercept)
iq[[s]]$pellets_taken <- exp(iq[[s]]$is)
}
iq[s+1] <- list(extract.samples(intake_output[[s]]))
iq[[s+1]]$intercept <- matrix(0,nrow(iq[[1]]$intercept),ncol(iq[[1]]$intercept))
coerce_index(Behav$Rat)
install.packages('rethinking',type='source'))install.packages(c('devtools','coda','mvtnorm')) library(devtools) install_github("rmcelreath/rethinking")
install.packages('rethinking',type='source')
install.packages("rethinking", type = "source")
library(rethinking)
install.packages(c("ggplot2", "readr"))
library(rethinking)
# Run all of the following code, either by selecting all the code and
# pressing the "Run" button (if you are using RStudio) or by copying
# the code and pasting it into the R console and pressing return.
# This bit of code installs the "rstan" package, which is essential to
# the Stan programming language that will do the heavy lifting in the
# background later in the course. Without running this installer first,
# the "rethinking" package won't work properly.
remove.packages("rstan")
install.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
# Once "rstan" is installed, we can install the "rethinking" package
# proper, drawn directly from the author's website.
install.packages(c("mvtnorm","loo","coda"), repos="https://cloud.r-project.org/",dependencies=TRUE)
install.packages('rethinking',type='source')
library("rstan")
library("rethinking")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
# If everything has gone according to plan, you should now be able
# to to use the full scope of the tools in the rethinking package.
# If you run into difficulty, let me know ASAP so we can
# troubleshoot the problem.
library(rethinking)
install.packages('rethinking',type='source'))install.packages(c('devtools','coda','mvtnorm')) library(devtools) install_github("rmcelreath/rethinking"))
install.packages('rethinking',type='source'))
install.packages('rethinking',type='source')
install.packages(c('devtools','coda','mvtnorm'))
install.packages(c('coda','mvtnorm')) options(repos=c(getOption('repos'),rethinking='http://xcelab.net/R'))
install.packages(c('coda','mvtnorm'))
options(repos=c(getOption('repos'),rethinking='http://xcelab.net/R'))
library(rethinking)
install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
install.packages(c("coda","mvtnorm","devtools","loo"))
install.packages(c("coda", "mvtnorm", "devtools", "loo"))
library(devtools)
devtools::install_github("rmcelreath/rethinking")
library(rethinking)
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
library(rethinking)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(MAKEFLAGS = "-j4") # four cores used
install.packages("rstan", type = "source")
library(rethinking)
library(rethinking)
install.packages(c("coda","mvtnorm","devtools","loo"))library(devtools)(devtools::install_github("rmcelreath/rethinking")
install.packages(c("coda","mvtnorm","devtools","loo"))
install.packages(c("coda", "mvtnorm", "devtools", "loo"))
library(devtools)(
devtools::install_github("rmcelreath/rethinking")
)
library(devtools)(devtools::install_github("rmcelreath/rethinking"))
library(devtools)
devtools::install_github("rmcelreath/rethinking")
library(rethinking)
library(rethinking)
install.packages('rethinking',type='source')
install.packages(c('devtools','coda','mvtnorm'))
install.packages(c("devtools", "coda", "mvtnorm"))
library(devtools)
install_github("rmcelreath/rethinking")
library(rethinking)
# Run all of the following code, either by selecting all the code and
# pressing the "Run" button (if you are using RStudio) or by copying
# the code and pasting it into the R console and pressing return.
# This bit of code installs the "rstan" package, which is essential to
# the Stan programming language that will do the heavy lifting in the
# background later in the course. Without running this installer first,
# the "rethinking" package won't work properly.
remove.packages("rstan")
install.packages("StanHeaders")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
pkgbuild::has_build_tools(debug = TRUE)
# Once "rstan" is installed, we can install the "rethinking" package
# proper, drawn directly from the author's website.
install.packages(c("mvtnorm","loo","coda"), repos="https://cloud.r-project.org/",dependencies=TRUE)
options(repos=c(getOption('repos'), rethinking='http://xcelab.net/R'))
install.packages('rethinking',type='source')
library("rstan")
library("rethinking")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
# If everything has gone according to plan, you should now be able
# to to use the full scope of the tools in the rethinking package.
# If you run into difficulty, let me know ASAP so we can
# troubleshoot the problem.
library(rethinking)
install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
install.packages(c("coda", "mvtnorm", "devtools"))
library(rethinking)
install.packages("Rcpp", repos = "https://rcppcore.github.io/drat")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(MAKEFLAGS = "-j4") # four cores used
install.packages("rstan", type = "source")
library(rethinking)
library(rstan)
library(rethinking)
install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
library(rethinking)
install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
install.packages(c("coda", "mvtnorm", "devtools"))
library(rethinking)
library(rethinking)
library(readr)
library(ggplot2)
setwd("~/Documents/Google Drive/Reed/Learning & Adaptive Behavior Laboratory/Sharing Data - Greg")
Behav <- read_csv("Raw_data.csv")
Behav$Subject <- coerce_index(Behav$Rat)
rstan_options(auto_write = TRUE);
options(mc.cores = parallel::detectCores());
pair_machine_p <- stan_model(file="pair_model.stan")
choice_output <- list()
cq <- list()
cyc <- 2000
for (s in unique(Behav$Subject)) {
dex <- (Behav$Condition!=5)&(Behav$Subject==s)
dat <- list(S=sum(dex),C=length(unique(Behav$Condition[dex])),N=Behav$Social[dex]+Behav$Food[dex],condID=Behav$Condition[dex],F=Behav$Food[dex])
dat$condID[dat$condID>5] <- dat$condID[dat$condID>5]-1
choice_output[s] <- list(sampling(pair_machine_p, data=dat, iter=cyc*2, warmup=cyc, chains=4, cores=4, control=list(adapt_delta=0.99,max_treedepth=15)))
cq[s] <- list(extract.samples(choice_output[[s]]))
cq[[s]]$prob <- inv_logit(cq[[s]]$intercept)
}
install.packages("survival")
